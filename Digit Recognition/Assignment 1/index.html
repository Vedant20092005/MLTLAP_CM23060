<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>MNIST CNN Training</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
</head>

<body>
  <h2>MNIST CNN Training (Check Console)</h2>

  <script>
    const IMAGE_SIZE = 28 * 28;
    const NUM_CLASSES = 10;
    const NUM_DATASET_ELEMENTS = 65000;
    const NUM_TRAIN_ELEMENTS = 55000;

    const MNIST_IMAGES_SPRITE =
      'https://storage.googleapis.com/learnjs-data/model-builder/mnist_images.png';
    const MNIST_LABELS_PATH =
      'https://storage.googleapis.com/learnjs-data/model-builder/mnist_labels_uint8';

    class MnistData {
      async load() {
        const img = new Image();
        img.crossOrigin = '';
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        const imgRequest = new Promise(resolve => {
          img.onload = () => resolve();
          img.src = MNIST_IMAGES_SPRITE;
        });

        const labelsRequest = fetch(MNIST_LABELS_PATH);
        await Promise.all([imgRequest, labelsRequest]);

        const labels = new Uint8Array(await (await labelsRequest).arrayBuffer());

        const datasetBytesBuffer =
          new ArrayBuffer(NUM_DATASET_ELEMENTS * IMAGE_SIZE * 4);

        const chunkSize = 5000;
        canvas.width = img.width;
        canvas.height = chunkSize;

        for (let i = 0; i < NUM_DATASET_ELEMENTS / chunkSize; i++) {
          ctx.drawImage(
            img,
            0,
            i * chunkSize,
            img.width,
            chunkSize,
            0,
            0,
            img.width,
            chunkSize
          );

          const imageData = ctx.getImageData(
            0,
            0,
            canvas.width,
            canvas.height
          );

          const pixels = imageData.data;
          const datasetBytesView = new Float32Array(
            datasetBytesBuffer,
            i * IMAGE_SIZE * chunkSize * 4,
            IMAGE_SIZE * chunkSize
          );

          for (let j = 0; j < pixels.length / 4; j++) {
            datasetBytesView[j] = pixels[j * 4] / 255;
          }
        }

        this.images = new Float32Array(datasetBytesBuffer);
        this.labels = labels;

        this.trainImages = this.images.slice(0, IMAGE_SIZE * NUM_TRAIN_ELEMENTS);
        this.trainLabels = this.labels.slice(0, NUM_TRAIN_ELEMENTS * NUM_CLASSES);

        this.testImages = this.images.slice(IMAGE_SIZE * NUM_TRAIN_ELEMENTS);
        this.testLabels = this.labels.slice(NUM_TRAIN_ELEMENTS * NUM_CLASSES);
      }
    }

    async function run() {
      console.log("Loading MNIST data...");
      const data = new MnistData();
      await data.load();

      const xTrain = tf.tensor4d(data.trainImages, [NUM_TRAIN_ELEMENTS, 28, 28, 1]);
      const yTrain = tf.tensor2d(data.trainLabels, [NUM_TRAIN_ELEMENTS, 10]);

      const model = tf.sequential();
      model.add(tf.layers.conv2d({
        inputShape: [28, 28, 1],
        filters: 8,
        kernelSize: 3,
        activation: 'relu'
      }));
      model.add(tf.layers.maxPooling2d({ poolSize: 2 }));
      model.add(tf.layers.flatten());
      model.add(tf.layers.dense({ units: 10, activation: 'softmax' }));

      model.compile({
        optimizer: 'adam',
        loss: 'categoricalCrossentropy',
        metrics: ['accuracy']
      });

      console.log("Training started...");
      await model.fit(xTrain, yTrain, {
        epochs: 2,
        batchSize: 64,
        callbacks: {
          onEpochEnd: (epoch, logs) => {
            console.log(
              `Epoch ${epoch + 1}: loss=${logs.loss.toFixed(4)}, accuracy=${logs.acc.toFixed(4)}`
            );
          }
        }
      });

      console.log("Training completed");
    }

    run();
  </script>
</body>
</html>
